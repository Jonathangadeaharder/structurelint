// Package init provides auto-configuration functionality for structurelint.
package init

import (
	"fmt"
	"strings"
)

// GenerateConfig creates a .structurelint.yml configuration based on detected project info
func GenerateConfig(info *ProjectInfo) string {
	var sb strings.Builder

	writeHeader(&sb)
	writeExclusions(&sb, info)
	writeBasicRules(&sb, info)
	writeDocumentationRules(&sb, info)
	writeDisallowedPatterns(&sb)
	writeTestRules(&sb, info)
	writeLayersSection(&sb, info)
	writeEntrypointsSection(&sb, info)

	return sb.String()
}

func writeHeader(sb *strings.Builder) {
	sb.WriteString("# structurelint configuration\n")
	sb.WriteString("# Generated by: structurelint --init\n")
	sb.WriteString("# Documentation: https://github.com/structurelint/structurelint\n\n")
	sb.WriteString("root: true\n\n")
}

func writeExclusions(sb *strings.Builder, info *ProjectInfo) {
	sb.WriteString("exclude:\n")
	sb.WriteString("  - testdata/**\n")
	sb.WriteString("  - .git/**\n")

	// Language-specific exclusions
	for _, lang := range info.Languages {
		writeLanguageExclusions(sb, lang.Language)
	}
	sb.WriteString("\n")
}

func writeLanguageExclusions(sb *strings.Builder, lang string) {
	switch lang {
	case "javascript", "typescript":
		sb.WriteString("  - node_modules/**\n")
		sb.WriteString("  - dist/**\n")
		sb.WriteString("  - build/**\n")
	case "go":
		sb.WriteString("  - vendor/**\n")
	case "python":
		sb.WriteString("  - __pycache__/**\n")
		sb.WriteString("  - .pytest_cache/**\n")
		sb.WriteString("  - venv/**\n")
		sb.WriteString("  - .venv/**\n")
	case "java":
		sb.WriteString("  - target/**\n")
	case "rust":
		sb.WriteString("  - target/**\n")
	case "ruby":
		sb.WriteString("  - coverage/**\n")
	}
}

func writeBasicRules(sb *strings.Builder, info *ProjectInfo) {
	sb.WriteString("rules:\n")
	sb.WriteString("  # Phase 0: Basic filesystem structure\n")
	fmt.Fprintf(sb, "  max-depth:\n    max: %d\n\n", info.MaxDepth)
	fmt.Fprintf(sb, "  max-files-in-dir:\n    max: %d\n\n", info.MaxFilesInDir)
	fmt.Fprintf(sb, "  max-subdirs:\n    max: %d\n\n", info.MaxSubdirs)
}

func writeDocumentationRules(sb *strings.Builder, info *ProjectInfo) {
	switch info.DocumentationStyle {
	case "comprehensive":
		sb.WriteString("  # Documentation requirements\n")
		sb.WriteString("  # Your project has comprehensive documentation - enforcing README.md in all directories\n")
		sb.WriteString("  file-existence:\n")
		sb.WriteString("    \"README.md\": \"exists:1\"\n\n")
	case "minimal":
		sb.WriteString("  # Documentation requirements (commented out - enable when ready)\n")
		sb.WriteString("  # file-existence:\n")
		sb.WriteString("  #   \"README.md\": \"exists:1\"\n\n")
	}
}

func writeDisallowedPatterns(sb *strings.Builder) {
	sb.WriteString("  disallowed-patterns:\n")
	sb.WriteString("    - \"*.tmp\"\n")
	sb.WriteString("    - \"*.bak\"\n")
	sb.WriteString("    - \".DS_Store\"\n\n")
}

func writeTestRules(sb *strings.Builder, info *ProjectInfo) {
	if info.PrimaryLanguage == nil {
		return
	}

	lang := info.PrimaryLanguage
	sb.WriteString("  # Test file validation\n")
	fmt.Fprintf(sb, "  # Detected: %s with %s test pattern\n", lang.Language, lang.TestPattern)

	writeTestAdjacencyRule(sb, lang)
	writeTestLocationRule(sb, lang)
}

func writeTestAdjacencyRule(sb *strings.Builder, lang *LanguageInfo) {
	if lang.TestPattern == "adjacent" {
		sb.WriteString("  test-adjacency:\n")
		sb.WriteString("    pattern: \"adjacent\"\n")
		sb.WriteString("    file-patterns:\n")
		for _, pattern := range lang.SourcePatterns {
			fmt.Fprintf(sb, "      - \"%s\"\n", pattern)
		}
		sb.WriteString("    exemptions:\n")
		sb.WriteString(generateExemptions(lang.Language))
	} else if lang.TestPattern == "separate" && lang.TestDir != "" {
		sb.WriteString("  test-adjacency:\n")
		sb.WriteString("    pattern: \"separate\"\n")
		fmt.Fprintf(sb, "    test-dir: \"%s\"\n", lang.TestDir)
		sb.WriteString("    file-patterns:\n")
		for _, pattern := range lang.SourcePatterns {
			fmt.Fprintf(sb, "      - \"%s\"\n", pattern)
		}
		sb.WriteString("    exemptions:\n")
		sb.WriteString(generateExemptions(lang.Language))
	}
	sb.WriteString("\n")
}

func writeTestLocationRule(sb *strings.Builder, lang *LanguageInfo) {
	sb.WriteString("  test-location:\n")
	if lang.HasIntegrationDir {
		fmt.Fprintf(sb, "    integration-test-dir: \"%s\"\n", lang.IntegrationDir)
	} else {
		sb.WriteString("    integration-test-dir: \"tests\"  # Default integration test directory\n")
	}
	fmt.Fprintf(sb, "    allow-adjacent: %t\n", lang.TestPattern == "adjacent" || lang.TestPattern == "")
	sb.WriteString("    exemptions:\n")
	sb.WriteString("      - \"testdata/**\"\n")
	sb.WriteString("\n")
}

func writeLayersSection(sb *strings.Builder, info *ProjectInfo) {
	sb.WriteString("# Phase 1: Architectural layers (uncomment and customize)\n")
	sb.WriteString("# layers:\n")
	if info.PrimaryLanguage != nil {
		writeLanguageLayers(sb, info.PrimaryLanguage.Language)
	}
	sb.WriteString("\n")
}

func writeLanguageLayers(sb *strings.Builder, lang string) {
	switch lang {
	case "go":
		sb.WriteString("#   - name: cmd\n")
		sb.WriteString("#     path: cmd/**\n")
		sb.WriteString("#     dependsOn: [internal]\n")
		sb.WriteString("#\n")
		sb.WriteString("#   - name: internal\n")
		sb.WriteString("#     path: internal/**\n")
		sb.WriteString("#     dependsOn: []\n")
	case "typescript", "javascript":
		sb.WriteString("#   - name: presentation\n")
		sb.WriteString("#     path: src/components/**\n")
		sb.WriteString("#     dependsOn: [application, domain]\n")
		sb.WriteString("#\n")
		sb.WriteString("#   - name: application\n")
		sb.WriteString("#     path: src/services/**\n")
		sb.WriteString("#     dependsOn: [domain]\n")
		sb.WriteString("#\n")
		sb.WriteString("#   - name: domain\n")
		sb.WriteString("#     path: src/models/**\n")
		sb.WriteString("#     dependsOn: []\n")
	}
}

func writeEntrypointsSection(sb *strings.Builder, info *ProjectInfo) {
	sb.WriteString("# Phase 2: Dead code detection (uncomment to enable)\n")
	sb.WriteString("# entrypoints:\n")
	if info.PrimaryLanguage != nil {
		writeLanguageEntrypoints(sb, info.PrimaryLanguage.Language)
	}
}

func writeLanguageEntrypoints(sb *strings.Builder, lang string) {
	switch lang {
	case "go":
		sb.WriteString("#   - cmd/*/main.go\n")
		sb.WriteString("#   - \"**/*_test.go\"\n")
	case "typescript", "javascript":
		sb.WriteString("#   - src/index.ts\n")
		sb.WriteString("#   - src/main.ts\n")
		sb.WriteString("#   - \"**/*.test.ts\"\n")
		sb.WriteString("#   - \"**/*.spec.ts\"\n")
	case "python":
		sb.WriteString("#   - \"main.py\"\n")
		sb.WriteString("#   - \"__main__.py\"\n")
		sb.WriteString("#   - \"test_*.py\"\n")
		sb.WriteString("#   - \"*_test.py\"\n")
	}
}

// generateExemptions returns language-specific test exemption patterns
func generateExemptions(lang string) string {
	exemptions := make([]string, 0)

	switch lang {
	case "go":
		exemptions = append(exemptions,
			"      - \"cmd/**/*.go\"       # Entry points don't need tests",
			"      - \"**/*_gen.go\"       # Generated files",
			"      - \"vendor/**\"",
		)
	case "python":
		exemptions = append(exemptions,
			"      - \"**/__init__.py\"    # Package initializers",
			"      - \"**/conftest.py\"    # Pytest configuration",
			"      - \"setup.py\"          # Setup script",
		)
	case "typescript", "javascript":
		exemptions = append(exemptions,
			"      - \"**/*.d.ts\"         # Type definitions",
			"      - \"**/index.ts\"       # Re-exports",
			"      - \"**/*.config.ts\"    # Configuration files",
		)
	case "java":
		exemptions = append(exemptions,
			"      - \"**/Main.java\"      # Entry points",
			"      - \"**/Application.java\"",
		)
	case "rust":
		exemptions = append(exemptions,
			"      - \"**/main.rs\"        # Entry points",
			"      - \"**/lib.rs\"         # Library roots",
		)
	case "ruby":
		exemptions = append(exemptions,
			"      - \"**/config/**\"      # Configuration",
			"      - \"db/migrate/**\"     # Database migrations",
		)
	default:
		exemptions = append(exemptions,
			"      - \"**/*_gen.*\"        # Generated files",
		)
	}

	return strings.Join(exemptions, "\n") + "\n"
}

// GenerateSummary creates a human-readable summary of detected configuration
func GenerateSummary(info *ProjectInfo) string {
	var sb strings.Builder

	sb.WriteString("ðŸ” Project Analysis Summary\n")
	sb.WriteString("===========================\n\n")

	// Languages
	sb.WriteString("Languages Detected:\n")
	for i, lang := range info.Languages {
		marker := " "
		if i == 0 {
			marker = "âœ“"
		}
		fmt.Fprintf(&sb, "  [%s] %s (%d files)\n", marker, lang.Language, lang.FileCount)

		if lang.TestPattern != "" {
			fmt.Fprintf(&sb, "      Test pattern: %s\n", lang.TestPattern)
		}
		if lang.TestDir != "" {
			fmt.Fprintf(&sb, "      Test directory: %s/\n", lang.TestDir)
		}
		if lang.HasIntegrationDir {
			fmt.Fprintf(&sb, "      Integration tests: %s/\n", lang.IntegrationDir)
		}
	}
	sb.WriteString("\n")

	// Structure metrics
	sb.WriteString("Project Structure:\n")
	fmt.Fprintf(&sb, "  Max depth: %d levels\n", info.MaxDepth)
	fmt.Fprintf(&sb, "  Max files per directory: %d\n", info.MaxFilesInDir)
	fmt.Fprintf(&sb, "  Max subdirectories: %d\n", info.MaxSubdirs)
	sb.WriteString("\n")

	// Documentation
	sb.WriteString("Documentation:\n")
	switch info.DocumentationStyle {
	case "comprehensive":
		sb.WriteString("  âœ“ Comprehensive (READMEs in most directories)\n")
	case "minimal":
		sb.WriteString("  âš  Minimal (few READMEs found)\n")
	case "none":
		sb.WriteString("  âœ— None (no READMEs found)\n")
	}
	sb.WriteString("\n")

	// Recommendations
	sb.WriteString("Recommendations:\n")
	if info.PrimaryLanguage != nil {
		lang := info.PrimaryLanguage
		if lang.TestPattern == "" {
			sb.WriteString("  âš  No clear test pattern detected. Consider adding tests.\n")
		} else {
			fmt.Fprintf(&sb, "  âœ“ Test pattern detected: %s\n", lang.TestPattern)
		}
	}

	if info.DocumentationStyle == "none" {
		sb.WriteString("  âš  Consider adding README.md files to document your code\n")
	}

	if info.MaxDepth > 8 {
		sb.WriteString("  âš  Deep nesting detected. Consider flattening directory structure\n")
	}

	sb.WriteString("\n")
	sb.WriteString("Configuration has been generated based on these findings.\n")
	sb.WriteString("Review and customize .structurelint.yml as needed.\n")

	return sb.String()
}
