package init

import (
	"fmt"
	"strings"
)

// GenerateConfig creates a .structurelint.yml configuration based on detected project info
func GenerateConfig(info *ProjectInfo) string {
	var sb strings.Builder

	// Header
	sb.WriteString("# structurelint configuration\n")
	sb.WriteString("# Generated by: structurelint --init\n")
	sb.WriteString("# Documentation: https://github.com/structurelint/structurelint\n\n")

	sb.WriteString("root: true\n\n")

	// Exclusions
	sb.WriteString("exclude:\n")
	sb.WriteString("  - testdata/**\n")
	sb.WriteString("  - .git/**\n")

	// Language-specific exclusions
	for _, lang := range info.Languages {
		switch lang.Language {
		case "javascript", "typescript":
			sb.WriteString("  - node_modules/**\n")
			sb.WriteString("  - dist/**\n")
			sb.WriteString("  - build/**\n")
		case "go":
			sb.WriteString("  - vendor/**\n")
		case "python":
			sb.WriteString("  - __pycache__/**\n")
			sb.WriteString("  - .pytest_cache/**\n")
			sb.WriteString("  - venv/**\n")
			sb.WriteString("  - .venv/**\n")
		case "java":
			sb.WriteString("  - target/**\n")
		case "rust":
			sb.WriteString("  - target/**\n")
		case "ruby":
			sb.WriteString("  - coverage/**\n")
		}
	}
	sb.WriteString("\n")

	// Rules
	sb.WriteString("rules:\n")

	// Phase 0: Basic filesystem rules
	sb.WriteString("  # Phase 0: Basic filesystem structure\n")
	sb.WriteString(fmt.Sprintf("  max-depth:\n    max: %d\n\n", info.MaxDepth))
	sb.WriteString(fmt.Sprintf("  max-files-in-dir:\n    max: %d\n\n", info.MaxFilesInDir))
	sb.WriteString(fmt.Sprintf("  max-subdirs:\n    max: %d\n\n", info.MaxSubdirs))

	// Documentation rules
	switch info.DocumentationStyle {
	case "comprehensive":
		sb.WriteString("  # Documentation requirements\n")
		sb.WriteString("  # Your project has comprehensive documentation - enforcing README.md in all directories\n")
		sb.WriteString("  file-existence:\n")
		sb.WriteString("    \"README.md\": \"exists:1\"\n\n")
	case "minimal":
		sb.WriteString("  # Documentation requirements (commented out - enable when ready)\n")
		sb.WriteString("  # file-existence:\n")
		sb.WriteString("  #   \"README.md\": \"exists:1\"\n\n")
	}

	// Disallowed patterns
	sb.WriteString("  disallowed-patterns:\n")
	sb.WriteString("    - \"*.tmp\"\n")
	sb.WriteString("    - \"*.bak\"\n")
	sb.WriteString("    - \".DS_Store\"\n\n")

	// Test validation rules
	if info.PrimaryLanguage != nil {
		lang := info.PrimaryLanguage
		sb.WriteString("  # Test file validation\n")
		sb.WriteString(fmt.Sprintf("  # Detected: %s with %s test pattern\n", lang.Language, lang.TestPattern))

		if lang.TestPattern == "adjacent" {
			sb.WriteString("  test-adjacency:\n")
			sb.WriteString("    pattern: \"adjacent\"\n")
			sb.WriteString("    file-patterns:\n")
			for _, pattern := range lang.SourcePatterns {
				// Exclude test files from pattern
				sb.WriteString(fmt.Sprintf("      - \"%s\"\n", pattern))
			}

			// Add exemptions
			sb.WriteString("    exemptions:\n")
			sb.WriteString(generateExemptions(lang.Language))

		} else if lang.TestPattern == "separate" && lang.TestDir != "" {
			sb.WriteString("  test-adjacency:\n")
			sb.WriteString("    pattern: \"separate\"\n")
			sb.WriteString(fmt.Sprintf("    test-dir: \"%s\"\n", lang.TestDir))
			sb.WriteString("    file-patterns:\n")
			for _, pattern := range lang.SourcePatterns {
				sb.WriteString(fmt.Sprintf("      - \"%s\"\n", pattern))
			}
			sb.WriteString("    exemptions:\n")
			sb.WriteString(generateExemptions(lang.Language))
		}

		sb.WriteString("\n")

		// Test location rule
		sb.WriteString("  test-location:\n")
		if lang.HasIntegrationDir {
			sb.WriteString(fmt.Sprintf("    integration-test-dir: \"%s\"\n", lang.IntegrationDir))
		} else {
			sb.WriteString("    integration-test-dir: \"tests\"  # Default integration test directory\n")
		}
		sb.WriteString(fmt.Sprintf("    allow-adjacent: %t\n", lang.TestPattern == "adjacent" || lang.TestPattern == ""))
		sb.WriteString("    exemptions:\n")
		sb.WriteString("      - \"testdata/**\"\n")
		sb.WriteString("\n")
	}

	// Layers (if applicable - commented out for now)
	sb.WriteString("# Phase 1: Architectural layers (uncomment and customize)\n")
	sb.WriteString("# layers:\n")
	if info.PrimaryLanguage != nil {
		switch info.PrimaryLanguage.Language {
		case "go":
			sb.WriteString("#   - name: cmd\n")
			sb.WriteString("#     path: cmd/**\n")
			sb.WriteString("#     dependsOn: [internal]\n")
			sb.WriteString("#\n")
			sb.WriteString("#   - name: internal\n")
			sb.WriteString("#     path: internal/**\n")
			sb.WriteString("#     dependsOn: []\n")
		case "typescript", "javascript":
			sb.WriteString("#   - name: presentation\n")
			sb.WriteString("#     path: src/components/**\n")
			sb.WriteString("#     dependsOn: [application, domain]\n")
			sb.WriteString("#\n")
			sb.WriteString("#   - name: application\n")
			sb.WriteString("#     path: src/services/**\n")
			sb.WriteString("#     dependsOn: [domain]\n")
			sb.WriteString("#\n")
			sb.WriteString("#   - name: domain\n")
			sb.WriteString("#     path: src/models/**\n")
			sb.WriteString("#     dependsOn: []\n")
		}
	}
	sb.WriteString("\n")

	// Entrypoints (if applicable)
	sb.WriteString("# Phase 2: Dead code detection (uncomment to enable)\n")
	sb.WriteString("# entrypoints:\n")
	if info.PrimaryLanguage != nil {
		switch info.PrimaryLanguage.Language {
		case "go":
			sb.WriteString("#   - cmd/*/main.go\n")
			sb.WriteString("#   - \"**/*_test.go\"\n")
		case "typescript", "javascript":
			sb.WriteString("#   - src/index.ts\n")
			sb.WriteString("#   - src/main.ts\n")
			sb.WriteString("#   - \"**/*.test.ts\"\n")
			sb.WriteString("#   - \"**/*.spec.ts\"\n")
		case "python":
			sb.WriteString("#   - \"main.py\"\n")
			sb.WriteString("#   - \"__main__.py\"\n")
			sb.WriteString("#   - \"test_*.py\"\n")
			sb.WriteString("#   - \"*_test.py\"\n")
		}
	}

	return sb.String()
}

// generateExemptions returns language-specific test exemption patterns
func generateExemptions(lang string) string {
	exemptions := make([]string, 0)

	switch lang {
	case "go":
		exemptions = append(exemptions,
			"      - \"cmd/**/*.go\"       # Entry points don't need tests",
			"      - \"**/*_gen.go\"       # Generated files",
			"      - \"vendor/**\"",
		)
	case "python":
		exemptions = append(exemptions,
			"      - \"**/__init__.py\"    # Package initializers",
			"      - \"**/conftest.py\"    # Pytest configuration",
			"      - \"setup.py\"          # Setup script",
		)
	case "typescript", "javascript":
		exemptions = append(exemptions,
			"      - \"**/*.d.ts\"         # Type definitions",
			"      - \"**/index.ts\"       # Re-exports",
			"      - \"**/*.config.ts\"    # Configuration files",
		)
	case "java":
		exemptions = append(exemptions,
			"      - \"**/Main.java\"      # Entry points",
			"      - \"**/Application.java\"",
		)
	case "rust":
		exemptions = append(exemptions,
			"      - \"**/main.rs\"        # Entry points",
			"      - \"**/lib.rs\"         # Library roots",
		)
	case "ruby":
		exemptions = append(exemptions,
			"      - \"**/config/**\"      # Configuration",
			"      - \"db/migrate/**\"     # Database migrations",
		)
	default:
		exemptions = append(exemptions,
			"      - \"**/*_gen.*\"        # Generated files",
		)
	}

	return strings.Join(exemptions, "\n") + "\n"
}

// GenerateSummary creates a human-readable summary of detected configuration
func GenerateSummary(info *ProjectInfo) string {
	var sb strings.Builder

	sb.WriteString("ðŸ” Project Analysis Summary\n")
	sb.WriteString("===========================\n\n")

	// Languages
	sb.WriteString("Languages Detected:\n")
	for i, lang := range info.Languages {
		marker := " "
		if i == 0 {
			marker = "âœ“"
		}
		sb.WriteString(fmt.Sprintf("  [%s] %s (%d files)\n", marker, lang.Language, lang.FileCount))

		if lang.TestPattern != "" {
			sb.WriteString(fmt.Sprintf("      Test pattern: %s\n", lang.TestPattern))
		}
		if lang.TestDir != "" {
			sb.WriteString(fmt.Sprintf("      Test directory: %s/\n", lang.TestDir))
		}
		if lang.HasIntegrationDir {
			sb.WriteString(fmt.Sprintf("      Integration tests: %s/\n", lang.IntegrationDir))
		}
	}
	sb.WriteString("\n")

	// Structure metrics
	sb.WriteString("Project Structure:\n")
	sb.WriteString(fmt.Sprintf("  Max depth: %d levels\n", info.MaxDepth))
	sb.WriteString(fmt.Sprintf("  Max files per directory: %d\n", info.MaxFilesInDir))
	sb.WriteString(fmt.Sprintf("  Max subdirectories: %d\n", info.MaxSubdirs))
	sb.WriteString("\n")

	// Documentation
	sb.WriteString("Documentation:\n")
	switch info.DocumentationStyle {
	case "comprehensive":
		sb.WriteString("  âœ“ Comprehensive (READMEs in most directories)\n")
	case "minimal":
		sb.WriteString("  âš  Minimal (few READMEs found)\n")
	case "none":
		sb.WriteString("  âœ— None (no READMEs found)\n")
	}
	sb.WriteString("\n")

	// Recommendations
	sb.WriteString("Recommendations:\n")
	if info.PrimaryLanguage != nil {
		lang := info.PrimaryLanguage
		if lang.TestPattern == "" {
			sb.WriteString("  âš  No clear test pattern detected. Consider adding tests.\n")
		} else {
			sb.WriteString(fmt.Sprintf("  âœ“ Test pattern detected: %s\n", lang.TestPattern))
		}
	}

	if info.DocumentationStyle == "none" {
		sb.WriteString("  âš  Consider adding README.md files to document your code\n")
	}

	if info.MaxDepth > 8 {
		sb.WriteString("  âš  Deep nesting detected. Consider flattening directory structure\n")
	}

	sb.WriteString("\n")
	sb.WriteString("Configuration has been generated based on these findings.\n")
	sb.WriteString("Review and customize .structurelint.yml as needed.\n")

	return sb.String()
}
