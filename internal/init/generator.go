// Package init provides auto-configuration functionality for structurelint.
package init

import (
	"fmt"
	"strings"
)

// GenerateConfig creates a .structurelint.yml configuration based on detected project info
func GenerateConfig(info *ProjectInfo) string {
	var sb strings.Builder

	sb.WriteString(generateHeader())
	sb.WriteString(generateExclusions(info))
	sb.WriteString("rules:\n")
	sb.WriteString(generateBasicRules(info))
	sb.WriteString(generateDocumentationRules(info))
	sb.WriteString(generateDisallowedPatterns())

	if info.PrimaryLanguage != nil {
		sb.WriteString(generateTestValidationRules(info.PrimaryLanguage))
	}

	sb.WriteString(generateLayersComment(info))
	sb.WriteString(generateEntrypointsComment(info))

	return sb.String()
}

// generateHeader creates the configuration file header
func generateHeader() string {
	var sb strings.Builder
	sb.WriteString("# structurelint configuration\n")
	sb.WriteString("# Generated by: structurelint --init\n")
	sb.WriteString("# Documentation: https://github.com/structurelint/structurelint\n\n")
	sb.WriteString("root: true\n\n")
	return sb.String()
}

// generateExclusions creates the exclude section based on detected languages
func generateExclusions(info *ProjectInfo) string {
	var sb strings.Builder
	sb.WriteString("exclude:\n")
	sb.WriteString("  - testdata/**\n")
	sb.WriteString("  - .git/**\n")

	// Track which exclusions we've already added to avoid duplicates
	addedExclusions := make(map[string]bool)

	for _, lang := range info.Languages {
		exclusions := getLanguageExclusions(lang.Language)
		for _, exclusion := range exclusions {
			if !addedExclusions[exclusion] {
				sb.WriteString(exclusion)
				addedExclusions[exclusion] = true
			}
		}
	}
	sb.WriteString("\n")
	return sb.String()
}

// getLanguageExclusions returns exclusion patterns for a specific language
func getLanguageExclusions(language string) []string {
	switch language {
	case "javascript", "typescript":
		return []string{
			"  - node_modules/**\n",
			"  - dist/**\n",
			"  - build/**\n",
		}
	case "go":
		return []string{"  - vendor/**\n"}
	case "python":
		return []string{
			"  - __pycache__/**\n",
			"  - .pytest_cache/**\n",
			"  - venv/**\n",
			"  - .venv/**\n",
		}
	case "java":
		return []string{"  - target/**\n"}
	case "rust":
		return []string{"  - target/**\n"}
	case "ruby":
		return []string{"  - coverage/**\n"}
	default:
		return nil
	}
}

// generateBasicRules creates the basic filesystem structure rules
func generateBasicRules(info *ProjectInfo) string {
	var sb strings.Builder
	sb.WriteString("  # Phase 0: Basic filesystem structure\n")
	sb.WriteString(fmt.Sprintf("  max-depth:\n    max: %d\n\n", info.MaxDepth))
	sb.WriteString(fmt.Sprintf("  max-files-in-dir:\n    max: %d\n\n", info.MaxFilesInDir))
	sb.WriteString(fmt.Sprintf("  max-subdirs:\n    max: %d\n\n", info.MaxSubdirs))
	return sb.String()
}

// generateDocumentationRules creates documentation requirement rules
func generateDocumentationRules(info *ProjectInfo) string {
	var sb strings.Builder

	switch info.DocumentationStyle {
	case "comprehensive":
		sb.WriteString("  # Documentation requirements\n")
		sb.WriteString("  # Your project has comprehensive documentation - enforcing README.md in all directories\n")
		sb.WriteString("  file-existence:\n")
		sb.WriteString("    \"README.md\": \"exists:1\"\n\n")
	case "minimal":
		sb.WriteString("  # Documentation requirements (commented out - enable when ready)\n")
		sb.WriteString("  # file-existence:\n")
		sb.WriteString("  #   \"README.md\": \"exists:1\"\n\n")
	}

	return sb.String()
}

// generateDisallowedPatterns creates the disallowed patterns rule
func generateDisallowedPatterns() string {
	var sb strings.Builder
	sb.WriteString("  disallowed-patterns:\n")
	sb.WriteString("    - \"*.tmp\"\n")
	sb.WriteString("    - \"*.bak\"\n")
	sb.WriteString("    - \".DS_Store\"\n\n")
	return sb.String()
}

// generateTestValidationRules creates test validation rules for the primary language
func generateTestValidationRules(lang *LanguageInfo) string {
	var sb strings.Builder

	sb.WriteString("  # Test file validation\n")
	sb.WriteString(fmt.Sprintf("  # Detected: %s with %s test pattern\n", lang.Language, lang.TestPattern))

	if lang.TestPattern == "adjacent" {
		sb.WriteString(generateAdjacentTestConfig(lang))
	} else if lang.TestPattern == "separate" && lang.TestDir != "" {
		sb.WriteString(generateSeparateTestConfig(lang))
	}

	sb.WriteString("\n")
	sb.WriteString(generateTestLocationRule(lang))

	return sb.String()
}

// generateAdjacentTestConfig creates configuration for adjacent test pattern
func generateAdjacentTestConfig(lang *LanguageInfo) string {
	var sb strings.Builder
	sb.WriteString("  test-adjacency:\n")
	sb.WriteString("    pattern: \"adjacent\"\n")
	sb.WriteString("    file-patterns:\n")
	for _, pattern := range lang.SourcePatterns {
		sb.WriteString(fmt.Sprintf("      - \"%s\"\n", pattern))
	}
	sb.WriteString("    exemptions:\n")
	sb.WriteString(generateExemptions(lang.Language))
	return sb.String()
}

// generateSeparateTestConfig creates configuration for separate test directory pattern
func generateSeparateTestConfig(lang *LanguageInfo) string {
	var sb strings.Builder
	sb.WriteString("  test-adjacency:\n")
	sb.WriteString("    pattern: \"separate\"\n")
	sb.WriteString(fmt.Sprintf("    test-dir: \"%s\"\n", lang.TestDir))
	sb.WriteString("    file-patterns:\n")
	for _, pattern := range lang.SourcePatterns {
		sb.WriteString(fmt.Sprintf("      - \"%s\"\n", pattern))
	}
	sb.WriteString("    exemptions:\n")
	sb.WriteString(generateExemptions(lang.Language))
	return sb.String()
}

// generateTestLocationRule creates the test-location rule configuration
func generateTestLocationRule(lang *LanguageInfo) string {
	var sb strings.Builder
	sb.WriteString("  test-location:\n")

	if lang.HasIntegrationDir {
		sb.WriteString(fmt.Sprintf("    integration-test-dir: \"%s\"\n", lang.IntegrationDir))
	} else {
		sb.WriteString("    integration-test-dir: \"tests\"  # Default integration test directory\n")
	}

	sb.WriteString(fmt.Sprintf("    allow-adjacent: %t\n", lang.TestPattern == "adjacent" || lang.TestPattern == ""))
	sb.WriteString("    exemptions:\n")
	sb.WriteString("      - \"testdata/**\"\n")
	sb.WriteString("\n")

	return sb.String()
}

// generateLayersComment creates commented layer configuration examples
func generateLayersComment(info *ProjectInfo) string {
	var sb strings.Builder
	sb.WriteString("# Phase 1: Architectural layers (uncomment and customize)\n")
	sb.WriteString("# layers:\n")

	if info.PrimaryLanguage != nil {
		sb.WriteString(getLayerExamples(info.PrimaryLanguage.Language))
	}

	sb.WriteString("\n")
	return sb.String()
}

// getLayerExamples returns language-specific layer configuration examples
func getLayerExamples(language string) string {
	switch language {
	case "go":
		return "#   - name: cmd\n" +
			"#     path: cmd/**\n" +
			"#     dependsOn: [internal]\n" +
			"#\n" +
			"#   - name: internal\n" +
			"#     path: internal/**\n" +
			"#     dependsOn: []\n"
	case "typescript", "javascript":
		return "#   - name: presentation\n" +
			"#     path: src/components/**\n" +
			"#     dependsOn: [application, domain]\n" +
			"#\n" +
			"#   - name: application\n" +
			"#     path: src/services/**\n" +
			"#     dependsOn: [domain]\n" +
			"#\n" +
			"#   - name: domain\n" +
			"#     path: src/models/**\n" +
			"#     dependsOn: []\n"
	default:
		return ""
	}
}

// generateEntrypointsComment creates commented entrypoint configuration examples
func generateEntrypointsComment(info *ProjectInfo) string {
	var sb strings.Builder
	sb.WriteString("# Phase 2: Dead code detection (uncomment to enable)\n")
	sb.WriteString("# entrypoints:\n")

	if info.PrimaryLanguage != nil {
		sb.WriteString(getEntrypointExamples(info.PrimaryLanguage.Language))
	}

	return sb.String()
}

// getEntrypointExamples returns language-specific entrypoint configuration examples
func getEntrypointExamples(language string) string {
	switch language {
	case "go":
		return "#   - cmd/*/main.go\n" +
			"#   - \"**/*_test.go\"\n"
	case "typescript", "javascript":
		return "#   - src/index.ts\n" +
			"#   - src/main.ts\n" +
			"#   - \"**/*.test.ts\"\n" +
			"#   - \"**/*.spec.ts\"\n"
	case "python":
		return "#   - \"main.py\"\n" +
			"#   - \"__main__.py\"\n" +
			"#   - \"test_*.py\"\n" +
			"#   - \"*_test.py\"\n"
	default:
		return ""
	}
}

// generateExemptions returns language-specific test exemption patterns
func generateExemptions(lang string) string {
	exemptions := make([]string, 0)

	switch lang {
	case "go":
		exemptions = append(exemptions,
			"      - \"cmd/**/*.go\"       # Entry points don't need tests",
			"      - \"**/*_gen.go\"       # Generated files",
			"      - \"vendor/**\"",
		)
	case "python":
		exemptions = append(exemptions,
			"      - \"**/__init__.py\"    # Package initializers",
			"      - \"**/conftest.py\"    # Pytest configuration",
			"      - \"setup.py\"          # Setup script",
		)
	case "typescript", "javascript":
		exemptions = append(exemptions,
			"      - \"**/*.d.ts\"         # Type definitions",
			"      - \"**/index.ts\"       # Re-exports",
			"      - \"**/*.config.ts\"    # Configuration files",
		)
	case "java":
		exemptions = append(exemptions,
			"      - \"**/Main.java\"      # Entry points",
			"      - \"**/Application.java\"",
		)
	case "rust":
		exemptions = append(exemptions,
			"      - \"**/main.rs\"        # Entry points",
			"      - \"**/lib.rs\"         # Library roots",
		)
	case "ruby":
		exemptions = append(exemptions,
			"      - \"**/config/**\"      # Configuration",
			"      - \"db/migrate/**\"     # Database migrations",
		)
	default:
		exemptions = append(exemptions,
			"      - \"**/*_gen.*\"        # Generated files",
		)
	}

	return strings.Join(exemptions, "\n") + "\n"
}

// GenerateSummary creates a human-readable summary of detected configuration
func GenerateSummary(info *ProjectInfo) string {
	var sb strings.Builder

	sb.WriteString("ðŸ” Project Analysis Summary\n")
	sb.WriteString("===========================\n\n")

	// Languages
	sb.WriteString("Languages Detected:\n")
	for i, lang := range info.Languages {
		marker := " "
		if i == 0 {
			marker = "âœ“"
		}
		sb.WriteString(fmt.Sprintf("  [%s] %s (%d files)\n", marker, lang.Language, lang.FileCount))

		if lang.TestPattern != "" {
			sb.WriteString(fmt.Sprintf("      Test pattern: %s\n", lang.TestPattern))
		}
		if lang.TestDir != "" {
			sb.WriteString(fmt.Sprintf("      Test directory: %s/\n", lang.TestDir))
		}
		if lang.HasIntegrationDir {
			sb.WriteString(fmt.Sprintf("      Integration tests: %s/\n", lang.IntegrationDir))
		}
	}
	sb.WriteString("\n")

	// Structure metrics
	sb.WriteString("Project Structure:\n")
	sb.WriteString(fmt.Sprintf("  Max depth: %d levels\n", info.MaxDepth))
	sb.WriteString(fmt.Sprintf("  Max files per directory: %d\n", info.MaxFilesInDir))
	sb.WriteString(fmt.Sprintf("  Max subdirectories: %d\n", info.MaxSubdirs))
	sb.WriteString("\n")

	// Documentation
	sb.WriteString("Documentation:\n")
	switch info.DocumentationStyle {
	case "comprehensive":
		sb.WriteString("  âœ“ Comprehensive (READMEs in most directories)\n")
	case "minimal":
		sb.WriteString("  âš  Minimal (few READMEs found)\n")
	case "none":
		sb.WriteString("  âœ— None (no READMEs found)\n")
	}
	sb.WriteString("\n")

	// Recommendations
	sb.WriteString("Recommendations:\n")
	if info.PrimaryLanguage != nil {
		lang := info.PrimaryLanguage
		if lang.TestPattern == "" {
			sb.WriteString("  âš  No clear test pattern detected. Consider adding tests.\n")
		} else {
			sb.WriteString(fmt.Sprintf("  âœ“ Test pattern detected: %s\n", lang.TestPattern))
		}
	}

	if info.DocumentationStyle == "none" {
		sb.WriteString("  âš  Consider adding README.md files to document your code\n")
	}

	if info.MaxDepth > 8 {
		sb.WriteString("  âš  Deep nesting detected. Consider flattening directory structure\n")
	}

	sb.WriteString("\n")
	sb.WriteString("Configuration has been generated based on these findings.\n")
	sb.WriteString("Review and customize .structurelint.yml as needed.\n")

	return sb.String()
}
